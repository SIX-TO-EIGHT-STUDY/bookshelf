### 8. 자바 가상머신 이해하기
* 자바 프로그램은 javac 를 이용해 바이트코드 bytecode 로 컴파일된다. 이 바이트코드는 JVM 에서 명령어들을 아키텍처와 운영체제용으로 해석한다.

#### 가비지 컬렉션
#### 메모리는 어떻게 할당하는가?
* new 키워드는 자바 힙 영역에 메모리를 할당한다.
* 힙은 제너레이션이라는 몇 가지 영역으로 구분된다. 가비지 컬렉션에서 객체가 수집대상에서 제외된다면 다른 제너레이션으로 옮겨진다.
* 객체가 처음 생성됐을 때는 Eden 이라고 하는 메모리 영역에 할당된다. 그 후 가비지 컬렉션의 수집 대상에서 제외되면 Survivor 라고 하는 메모리 영역으로 옮겨지며,
이 공간에서 수집 대상에서 제외되는 객체는 Tenured 제너레이션에 할당된다.
* Permanent 제네레이션 또는 PermGen 이라고 하는 네 번째 제네레이션도 있다. 이 제네레이션에 속한 객체들은 가비지 컬렉션에서 수집할 때 선택되지 않고, 
일반적으로 클래스 정의나 String 상수 같이 JVM 에서 실행되는 데 필요한 불변(immutable) 상태가 포함된다.
* 참고로, 자바 8에서 PermGen 영역은 물리 메모리에 위치할 Metaspace 라는 새로운 영역으로 변경되었다.
[자바 메모리 관리](https://yaboong.github.io/java/2018/05/26/java-memory-management/)

#### 가비지 컬렉션이란 무엇인가?
* 가비지 컬렉션은 기존에 할당된 메모리를 재사용하는 매커니즘으로, 나중에 메모리를 할당할 때 재사용할 수 있다.
* 가비지 컬렉션 알고리즘은 몇 가지가 있다. 모든 작동 중인 코드에서 더 이상 참조하지 않는 메모리를 찾은 후 메모리를 할당할 때 이용할 수 있도록 반환한다는 공통의 목적이 있다.
* 그러므로 자바의 전통적인 가비지 컬렉션은 mark-and-sweep 방식이라고 한다.
* 실행 중인 코드에서 참조하는 객체는 live 로 표시되며 해당 객체에서 참조하는 것들 역시 확인해서 live 로 표시한다. 이는 현재 동작하는 객체의 모든 경로가 확인될 때까지 계속된다.
[JVM 메모리 구조](https://limkydev.tistory.com/51)

#### 메모리 튜닝
#### 스택과 힙의 차이는 무엇인가?
* 메모리는 스택과 힙의 두 가지 주요 영역으로 구분된다.
* 스택은 기본값, 객체의 참조, 메서드가 저장되는 위치다. 따라서 스택에 있는 변수의 생애주기는 코드의 스코프에 영향을 받는다.
* 스코프는 일반적으로 메서드 호출이나 for 문, while 문 같은 코드에서 괄호로 구분해서 정의한다. 일단 해당 스코프의 실행이 종료되면 스코프 안에 선언된 변수들은 스택에서 제거된다.

#### JVM 과 자바 사이의 상호작용
#### JVM 에서 동작하는 실제 자바 코드를 작성할 때 생명주기란 무엇인가?
* 컴파일 결과로 .class 확장자를 가진 파일인 바이트 코드가 생성되는데, 이 파일은 특정 아키텍처와 운영체제에서 실행되는 실행 파일과 유사항 바이너리 형식이며, JVM 용이라는 것만 다르다.
* 클래스 정의의 바이트 코드를 실행 중인 JVM 의 메모리로 가져오는 걸 클래스 로딩이라고 한다.
