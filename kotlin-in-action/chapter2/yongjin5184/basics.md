## 코틀린 기초

### 2.1 기본 요소: 함수와 변수
* 코틀린에서 타입 선언을 생략해도 된다는 사실을 보고, 코틀린이 어떻게 변경 가능한 데이터 보다 변경할 수 없는 불변 데이터 사용을 장려하는 지 배운다.

#### 2.1.1 Hello, World!
* 함수를 최상위 수준에 정의할 수 있다. (자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
* System.out.println 대신에 println 이라고 쓴다. 
  코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 wrapper 를 제공한다. println 도 그런 함수 중 하나다.

#### 2.1.2 함수
* 블록이 본문인 함수
```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

> 문(statement)과 식(expression)의 구분
> > 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
> > 코틀린에서 if 는 식이지 문이 아니다. 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.

* 식이 본문인 함수
```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

* 반환 타입 생략 
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

* 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 **타입 추론**이라 부른다.

#### 2.1.3 변수

* 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.
```kotlin
val answer: Int
answer = 42
```

* 변경 가능한 변수와 변경 불가능한 변수
> val (값을 뜻하는 value 에서 따옴)
> > 변경 불가능한 immutable 참조를 저장하는 변수다. val 로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. 자바로 말하자면 final 변수에 해당한다.

 
> var (변수를 뜻하는 variable 에서 따옴)
> > 변경 가능한 mutable 참조다. 이런 변수의 값은 바뀔 수있다. 자바의 일반 변수에 해당한다.

* 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 var 로 변경하라
* 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.


#### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```
* 이 예제는 **문자열 템플릿 기능**을 보여준다. 이 코드는 name 이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다.
여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.
  
* 문자열 템플릿 안에서 변수 이름만을 사용하는 경우라도 ${name} 처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다.

### 2.2 클래스와 프로퍼티

```kotlin
  class Person(val name: String)
```

* 이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 값 객체 (value object) 라 부르며, 
  다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.
* 코틀린의 기본 가시성 변경자 (Visibility modifier) 는 public 이다.

#### 2.2.1 프로퍼티
```kotlin
class Person(
  val name: String,
  var isMarried: Boolean
)
```
> val name
> > 읽기 전용 프로퍼티로, 코틀린은 (비공개) 필드와 필드를 읽는 단순한 (공개) 게터를 만들어 낸다.

> var isMarried
> > 쓸 수 있는 프로퍼티로, 코틀린은 (비공개) 필드, (공개) 게터, (공개) 세터를 만들어 낸다.

* 기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련있는 접근자를 선언하는 것이다.

#### 2.2.2 커스텀 접근자
```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get () {
            return height == width
        }
}
```

* 파라미터가 없는 함수와 커스텀 게터를 정의하는 방식은 구현이나 성능상 차이는 없다. 차이나는 부분은 가독성 뿐이다.

#### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
* 코틀린에서는 여러 클래스를 한 파일에 넣을 수도 있고, 파일의 이름도 마음대로 정할 수 있다.
* 하지만 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다. 특히 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는게 중요하다.