## 3. 객체 공유

### 시작
* 여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴본다.

### 3.1 가시성
* 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야 한다.
* 재배치(Reordering) 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이다.
* 병렬 프로그램에서 동기화가 완벽하게 맞춰지지 않았다면 정상적으로 작동할 것인지를 추측하기가 매우 어렵다. 
이런 어려움을 쉽게 극복할 수 있는 밥벙이 있다. '여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다'는 것이다.

#### 3.1.3 락과 가시성
* 값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 
다음 스레드가 사용할 수 있게 하기 위해 동일한 락을 사용하는 synchronized 블록으로 막아줄 필요가 있다.

#### 3.1.4 volatile 변수
*  volatile 로 선언된 변수의 값을 바꿧을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다. 
특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다.'고 이해한다.
* volatile 로 지정된 변수는 프로세서의 레지스터에 캐시되지도 않고, 
프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어 갈 수 있다.
* volatile 변수만 사용해 메모리 가시성을 확보하도록 작성한 코드는 synchronized 로 직접 동기화한 코드보다 훨씬 읽기가 어렵고, 
따라서 오류가 발생할 가능성도 높다.
* volatile 를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 
중요한 이벤트(초기화, 종료등)가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우등이 해당된다.
* 특정 변수의 값을 확인해 반복문을 빠져나갈 상황인지 확인하는 예이다. (boolean variable)
* volatile 연산자의 기본적인 능력으로는 증가 연산자(count++) 를 사용한 부분까지 동기화를 맞춰주지는 않는다.