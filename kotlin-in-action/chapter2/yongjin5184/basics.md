## 코틀린 기초

### 2.1 기본 요소: 함수와 변수
* 코틀린에서 타입 선언을 생략해도 된다는 사실을 보고, 코틀린이 어떻게 변경 가능한 데이터 보다 변경할 수 없는 불변 데이터 사용을 장려하는 지 배운다.

#### 2.1.1 Hello, World!
* 함수를 최상위 수준에 정의할 수 있다. (자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
* System.out.println 대신에 println 이라고 쓴다. 
  코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 wrapper 를 제공한다. println 도 그런 함수 중 하나다.

#### 2.1.2 함수
* 블록이 본문인 함수
```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

> 문(statement)과 식(expression)의 구분
> > 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
> > 코틀린에서 if 는 식이지 문이 아니다. 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.

* 식이 본문인 함수
```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

* 반환 타입 생략 
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

* 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 **타입 추론**이라 부른다.

#### 2.1.3 변수

* 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.
```kotlin
val answer: Int
answer = 42
```

* 변경 가능한 변수와 변경 불가능한 변수
> val (값을 뜻하는 value 에서 따옴)
> > 변경 불가능한 immutable 참조를 저장하는 변수다. val 로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. 자바로 말하자면 final 변수에 해당한다.

 
> var (변수를 뜻하는 variable 에서 따옴)
> > 변경 가능한 mutable 참조다. 이런 변수의 값은 바뀔 수있다. 자바의 일반 변수에 해당한다.

* 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 var 로 변경하라
* 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.


#### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```
* 이 예제는 **문자열 템플릿 기능**을 보여준다. 이 코드는 name 이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다.
여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.
  
* 문자열 템플릿 안에서 변수 이름만을 사용하는 경우라도 ${name} 처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다.