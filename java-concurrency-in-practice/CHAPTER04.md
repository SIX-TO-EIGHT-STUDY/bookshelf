## 4. 객체 구성

### 시작
* 스레드 안전성을 확보한 개별 컴포넌트를 가져다가 안전한 방법을 동원해 서로 연결해 사용한다면 규모 있는 컴포넌트나 프로그램을 좀더 쉽게 작성할 수 있다.

### 4.1 스레드 안전한 클레스 설계
* 클래스가 안전성을 확보하도록 설계하고자 할 때는 세 가지를 고려해야한다.
1. 객체의 상태를 보관하는 변수가 어떤 것인가?
2. 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
3. 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책

객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 **동기화 정책**이라고 한다.

#### 4.1.1 동기화 요구사항 정리
* 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있다면 바로 스레드 안전성을 확보했다고 할 수 있다.

#### 4.1.3 상태 의존 연산
* 어떤 동작을 실행하기 전에 특정한 조건을 만족할 때까지 기다리도록 프로그램하고자 한다면, wait 와 notify 를 사용하는 대신 
세마포어나 블로킹 큐와 같이 현재 알려져 있는 여러가지 라이브러리를 사용하는 편이 훨씬 간단하고 안전하다.

### 4.2 인스턴스 한정
* 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있는데, 이런 경우 흔히 '한정' 이라고 단순하게 부르기도 하는 '인스턴스 한정' 기법을 활용하는 셈이다.

```java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set<Person> mySet = new HashSet<Person>();
    
    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
```

* 자바 플랫폼의 클래스 라이브러리를 보면 스레드에 안전하지 않은 클래스의 스레드 안전성을 확보하기 위해 만들어져 있는 클래스도 있다.
Collections.synchronizedList 와 같은 팩토리 메소드가 만들어져 있다.

* 대부분 데코레이터 패턴을 활용하며 이런 팩토리 메소드의 결과로 만들어진 래퍼 클래스는 기본 클래스의 메소드를 호출하는 연동 역할만 하면서 그와 동시에 모든 메소드가 동기화되어 있다.